//| mill-version: 1.0.6

import almondbuild.*
import almondbuild.modules.*

import java.nio.charset.Charset
import java.nio.file.FileSystems

import com.github.lolgab.mill.mima._
import coursier.getcs.GetCs
import coursier.version.Version
import io.github.alexarchambault.millnativeimage.upload.Upload
import mill.*
import mill.api.*
import mill.scalalib.*
import mill.javalib.api.JvmWorkerUtil.isScala3
import _root_.scala.concurrent.duration._
import _root_.scala.util.Properties

lazy val millDiscover0         = Discover[this.type]
override lazy val millDiscover = millDiscover0

// Tell mill modules are under modules/
implicit def millModuleBasePath: ModuleCtx.Nested =
  MillCsHelper.moduleCtxWithDiscoverAndEnclosingModule(
    ModuleCtx.makeRoot(
      implicitly,
      implicitly,
      BuildCtx.workspaceRoot / "modules",
      Segments(),
      false,
      implicitly
    ),
    millDiscover0,
    this
  )

trait LoggerScala2Macros extends Cross.Module[String] with AlmondModule {
  def crossScalaVersion = crossValue
  def mvnDeps = Task {
    val sv = scalaVersion()
    if (isScala3(sv)) Seq.empty[Dep] else Seq(Deps.scalaReflect(sv))
  }
}

trait Logger extends Cross.Module[String] with AlmondModule {
  def crossScalaVersion = crossValue
  def moduleDeps =
    if (isScala3(crossScalaVersion)) Seq.empty
    else
      Seq(
        shared.`logger-scala2-macros`()
      )
  def mvnDeps = Task {
    val sv = scalaVersion()
    val scalaReflect =
      if (sv.startsWith("2.")) Seq(Deps.scalaReflect(sv))
      else Seq(mvn"org.scala-lang:scala3-library_3:$sv")
    scalaReflect
  }
  object test extends CrossSbtModuleTests with AlmondTestModule {
    // Getting transient errors upon incremental compilation without this
    def scalacOptions = super.scalacOptions
  }
}

trait Channels extends Cross.Module[String] with AlmondModule with AlmondMima {
  def crossScalaVersion = crossValue
  def moduleDeps = Seq(
    shared.logger()
  )
  def mvnDeps = Seq(
    Deps.fs2,
    Deps.jeromq
  )
  object test extends CrossSbtModuleTests with AlmondTestModule {
    // Getting transient errors upon incremental compilation without this
    def scalacOptions = super.scalacOptions
  }
}

trait Protocol extends Cross.Module[String] with AlmondModule {
  def crossScalaVersion = crossValue
  def moduleDeps = Seq(
    shared.channels()
  )
  def mvnDeps = Seq(
    Deps.jsoniterScalaCore
  )
  def compileMvnDeps = {
    val maybeScalaReflect =
      if (isScala3(crossScalaVersion)) Seq.empty[Dep]
      else Seq(Deps.scalaReflect(crossScalaVersion))
    maybeScalaReflect ++ Seq(
      Deps.jsoniterScalaMacros.withConfiguration("provided")
    )
  }
  object test extends CrossSbtModuleTests with AlmondTestModule {
    // Getting transient errors upon incremental compilation without this
    def scalacOptions = super.scalacOptions
  }
}

trait InterpreterApi extends Cross.Module[String] with AlmondModule with AlmondMima {
  def crossScalaVersion = crossValue

  def mimaBinaryIssueFilters = Seq(
    // abstract class not meant to be implemented by users
    ProblemFilter.exclude[ReversedMissingMethodProblem](
      "almond.interpreter.api.OutputHandler.*"
    )
  )
}

trait Interpreter extends Cross.Module[String] with AlmondModule {
  def crossScalaVersion = crossValue
  def moduleDeps = Seq(
    shared.`interpreter-api`(),
    shared.protocol()
  )
  def mvnDeps = Seq(
    Deps.collectionCompat,
    Deps.fansi,
    Deps.scalatags,
    Deps.slf4jNop
  )
  object test extends CrossSbtModuleTests with AlmondTestModule {
    // Getting transient errors upon incremental compilation without this
    def scalacOptions = super.scalacOptions
  }
}

trait Kernel extends Cross.Module[String] with AlmondModule {
  def crossScalaVersion = crossValue
  def moduleDeps = Seq(
    shared.interpreter()
  )
  def compileMvnDeps = Seq(
    Deps.jsoniterScalaMacros
  )
  def mvnDeps = Seq(
    Deps.caseAppAnnotations,
    Deps.collectionCompat,
    Deps.coursierApi,
    Deps.fs2
  )
  object test extends CrossSbtModuleTests with AlmondTestModule {
    def moduleDeps = super.moduleDeps ++ Seq(
      shared.interpreter().test,
      shared.`test-kit`()
    )
    // Getting transient errors upon incremental compilation without this
    def scalacOptions = super.scalacOptions
  }
}

trait Test extends Cross.Module[String] with AlmondModule {
  def crossScalaVersion = crossValue
  def moduleDeps = Seq(
    shared.`interpreter-api`()
  )
}

trait JupyterApi extends Cross.Module[String] with AlmondModule with AlmondMima {
  def crossScalaVersion = crossValue
  def moduleDeps = Seq(
    shared.`interpreter-api`()
  )
  def mvnDeps = Seq(
    Deps.jvmRepr
  )

  def mimaBinaryIssueFilters = Seq(
    // abstract class not meant to be implemented by users
    ProblemFilter.exclude[ReversedMissingMethodProblem]("almond.api.JupyterApi.*")
  )
}

trait ScalaKernelApi extends Cross.Module[String] with AlmondModule with DependencyListResource
    with ExternalSources with PropertyFile with AlmondMima {
  def crossScalaVersion     = crossValue
  def crossFullScalaVersion = true
  def moduleDeps = Seq(
    shared.`interpreter-api`(),
    scala.`jupyter-api`()
  )
  def mvnDeps = Seq(
    Deps.ammoniteCompiler.exclude(("org.slf4j", "slf4j-api")),
    Deps.ammoniteReplApi.exclude(("org.slf4j", "slf4j-api")),
    Deps.jvmRepr,
    Deps.coursierApi.exclude(("org.slf4j", "slf4j-api")),
    Deps.collectionCompat
  )

  def resolvedMvnDeps = Task {
    // Ensure we don't depend on slf4j-api
    // As no logger implem would be loaded alongside it by default, slf4j would fail to initialize,
    // complain in stderr, and default to NOP logging.
    val value = super.resolvedMvnDeps()
    val jarNames = value
      .map(_.path.last)
      .filter(_.endsWith(".jar"))
      .map(_.stripSuffix(".jar"))
    val slf4jJars = jarNames.filter(_.startsWith("slf4j-"))
    if (slf4jJars.nonEmpty)
      sys.error(s"Found slf4j JARs: ${slf4jJars.mkString(", ")}")
    value
  }

  def mimaPreviousVersions = Task {
    val minVersionMap = Map(
      "2.13.17" -> Version("0.14.2"),
      "2.13.18" -> Version("0.14.5"),
      "3.3.6"   -> Version("0.14.2"),
      "3.3.7"   -> Version("0.14.2"),
      "3.4.2"   -> Version("0.14.2"),
      "3.5.0"   -> Version("0.14.2"),
      "3.5.1"   -> Version("0.14.2"),
      "3.5.2"   -> Version("0.14.2"),
      "3.6.2"   -> Version("0.14.2"),
      "3.6.4"   -> Version("0.14.2"),
      "3.7.3"   -> Version("0.14.2"),
      "3.8.0"   -> Version("0.14.5")
    )
    val base = super.mimaPreviousVersions()
    minVersionMap.get(scalaVersion()) match {
      case Some(minVersion) => base.filter(Version(_) >= minVersion)
      case None             => base
    }
  }

  def propertyFilePath = "almond/almond.properties"
  def propertyExtra = Task {
    Seq(
      "default-scalafmt-version"        -> Deps.scalafmtDynamic.dep.versionConstraint.asString,
      "default-scalafmt-version-java-8" -> Versions.scalafmtJava8,
      "scala-version"                   -> crossScalaVersion
    )
  }

  // Getting transient errors upon incremental compilation without this
  def resources = super.resources
}

trait ScalaInterpreter extends Cross.Module[String] with AlmondModule {
  def crossScalaVersion     = crossValue
  def crossFullScalaVersion = true
  def moduleDeps = Seq(
    shared.interpreter(),
    scala.`coursier-logger`(),
    scala.`scala-kernel-api`(),
    scala.`shared-directives`(),
    scala.`toree-hooks`(ScalaVersions.binary(crossScalaVersion))
  )
  def mvnDeps = Task {
    val metabrowse =
      if (crossScalaVersion.startsWith("2."))
        Seq(
          // The scalameta versions of mtags (Metals) and Ammonite may clash here :\
          Deps.mtags
        )
      else
        Seq.empty
    metabrowse ++ Seq(
      Deps.coursier.withDottyCompat(crossScalaVersion),
      Deps.coursierApi,
      Deps.dependencyInterface,
      Deps.directiveHandler,
      Deps.jansi,
      Deps.ammoniteCompiler.exclude(("net.java.dev.jna", "jna")),
      Deps.ammoniteRepl.exclude(("net.java.dev.jna", "jna"))
    )
  }
  def compileMvnDeps = Seq(
    Deps.jsoniterScalaMacros
  )
  def scalacOptions = super.scalacOptions() ++ {
    val scala213Options =
      if (scalaVersion().startsWith("2.13.")) Seq("-Ymacro-annotations")
      else Nil
    scala213Options
  }
  def extraSources = Task.Sources(CrossSources.extraSourcesDirs(crossValue)*)
  def sources = Task {
    super.sources() ++ extraSources()
  }
  object test extends CrossSbtModuleTests with AlmondTestModule {
    def moduleDeps = {
      val rx =
        if (crossScalaVersion.startsWith("2.12.")) Seq(scala.`almond-rx`())
        else Nil
      super.moduleDeps ++ rx ++ Seq(
        shared.`test-kit`(),
        shared.kernel().test,
        scala.`test-definitions`()
      )
    }
    def mvnDeps = super.mvnDeps() ++ Seq(
      Deps.caseApp
    )
    def scalacOptions = Task {
      val base   = super.scalacOptions()
      val toDrop = Seq("--release", "8")
      val idx    = base.indexOfSlice(toDrop)
      if (idx >= 0)
        base.take(idx) ++ base.drop(idx + toDrop.length)
      else
        base
    }
    // Getting weird errors with test parallelism on CI when running all tests,
    // but getting weird ones locally with test parallelism disabled
    def testParallelism = System.getenv("CI") == null
  }
}

trait ScalaKernel extends Cross.Module[String] with AlmondModule with ExternalSources
    with BootstrapLauncher {
  def crossScalaVersion     = crossValue
  def crossFullScalaVersion = true
  def moduleDeps = Seq(
    shared.kernel(),
    scala.`scala-interpreter`()
  )
  def mvnDeps = Seq(
    Deps.caseApp,
    Deps.classPathUtil,
    Deps.scalafmtDynamic.withDottyCompat(crossScalaVersion)
  )
  object test extends CrossSbtModuleTests with AlmondTestModule {
    def moduleDeps = super.moduleDeps ++ Seq(
      scala.`scala-interpreter`().test
    )
    // Getting transient errors upon incremental compilation without this
    def scalacOptions = super.scalacOptions
  }

  def resolvedMvnDeps = Task {
    // Ensure we stay on slf4j 1.x
    // Kind of unnecessary now that scala-kernel-api doesn't bring slf4j-api any more,
    // but keeping that just in caseâ€¦
    val value = super.resolvedMvnDeps()
    val jarNames = value
      .map(_.path.last)
      .filter(_.endsWith(".jar"))
      .map(_.stripSuffix(".jar"))
    val slf4jJars = jarNames.filter(_.startsWith("slf4j-"))
    assert(slf4jJars.nonEmpty, "No slf4j JARs found")
    val wrongSlf4jVersionJars = slf4jJars.filter { name =>
      val version = name.split('-').dropWhile(_.head.isLetter).mkString("-")
      !version.startsWith("1.")
    }
    if (wrongSlf4jVersionJars.nonEmpty)
      sys.error(s"Found some slf4j non-1.x JARs: ${wrongSlf4jVersionJars.mkString(", ")}")

    value
  }

  def runClasspath =
    super.runClasspath() ++
      transitiveSources() ++
      externalSources()
  def launcherClassPath =
    transitiveJars() ++
      unmanagedClasspath() ++
      resolvedRunMvnDeps() ++
      transitiveSourceJars() ++
      externalSources()
  def launcherSharedClassPath = {
    val mod: AlmondModule & ExternalSources = scala.`scala-kernel-api`()
    mod.transitiveJars() ++
      mod.unmanagedClasspath() ++
      mod.resolvedRunMvnDeps() ++
      mod.transitiveSourceJars() ++
      mod.externalSources()
  }

  def manifest = Task {
    import java.util.jar.Attributes.Name
    val ver = publishVersion()
    super.manifest().add(
      Name.IMPLEMENTATION_TITLE.toString   -> "scala-kernel",
      Name.IMPLEMENTATION_VERSION.toString -> ver,
      Name.SPECIFICATION_VENDOR.toString   -> "sh.almond",
      Name.SPECIFICATION_TITLE.toString    -> "scala-kernel",
      "Implementation-Vendor-Id"           -> "sh.almond",
      "Specification-Version"              -> ver,
      Name.IMPLEMENTATION_VENDOR.toString  -> "sh.almond"
    )
  }
  def mainClass = Some("almond.ScalaKernel")

  def generatedSources: T[Seq[PathRef]] = Task {
    val constantsFileContent =
      s"""package almond.internal
         |
         |object Constants {
         |  def almondVersion = "${publishVersion()}"
         |  def actualScalaVersion = "${scalaVersion()}"
         |}
         |""".stripMargin
    os.write(Task.dest / "Constants.scala", constantsFileContent)
    Seq(PathRef(Task.dest)) ++ super.generatedSources()
  }
}

trait CoursierLogger extends Cross.Module[String] with AlmondModule {
  def crossScalaVersion = crossValue
  def moduleDeps = super.moduleDeps ++ Seq(
    shared.`interpreter-api`(),
    shared.logger()
  )
  def mvnDeps = super.mvnDeps() ++ Seq(
    Deps.collectionCompat,
    Deps.coursierApi,
    Deps.scalatags
  )
}

trait SharedDirectives extends Cross.Module[String] with AlmondModule {
  def crossScalaVersion = crossValue
  def mvnDeps = super.mvnDeps() ++ Seq(
    Deps.directiveHandler,
    Deps.jsoniterScalaCore
  )
  def compileMvnDeps = Seq(
    Deps.jsoniterScalaMacros
  )
}

trait Launcher extends AlmondSimpleModule with BootstrapLauncher with PropertyFile {
  private def sv   = ScalaVersions.scala3Latest
  def scalaVersion = sv
  def moduleDeps = Seq(
    scala.`coursier-logger`(ScalaVersions.scala3Compat),
    scala.`shared-directives`(ScalaVersions.scala3Compat),
    shared.kernel(ScalaVersions.scala3Compat)
  )
  def mvnDeps = Seq(
    Deps.caseApp,
    Deps.coursierLauncher,
    Deps.fansi,
    Deps.scalaparse
  )

  def propertyFilePath = "almond/launcher/launcher.properties"
  def propertyExtra = Task {
    val mainClass = scala.`scala-kernel`(ScalaVersions.scala3Latest).mainClass().getOrElse {
      sys.error("No main class found")
    }
    Seq(
      "kernel-main-class"        -> mainClass,
      "ammonite-version"         -> Versions.ammonite,
      "default-scala212-version" -> ScalaVersions.scala212,
      "default-scala213-version" -> ScalaVersions.scala213,
      "default-scala-version"    -> ScalaVersions.scala3Latest
    )
  }

  // Getting transient errors upon incremental compilation without this
  def resources = super.resources
}

trait AlmondScalaPy extends Cross.Module[String] with AlmondModule with AlmondMima {
  def crossScalaVersion = crossValue
  def mvnDeps = Seq(
    Deps.jvmRepr
  )
  def compileMvnDeps = Seq(
    Deps.scalapy
  )
}

trait AlmondRx extends Cross.Module[String] with AlmondModule with AlmondMima {
  def crossScalaVersion = crossValue
  def compileModuleDeps = Seq(
    scala.`scala-kernel-api`()
  )
  def mvnDeps = Seq(
    Deps.scalaRx
  )
}

trait JsonApiJackson extends Cross.Module[String] with AlmondModule with AlmondMima {
  def crossScalaVersion = crossValue
  def moduleDeps = Seq(
    scala.`jupyter-api`()
  )
  def mvnDeps = Seq(
    mvn"com.fasterxml.jackson.module::jackson-module-scala:2.19.2"
  )
  override def mimaPreviousVersions = Task {
    // module added only in 0.14.2
    val cutOff = Version("0.14.1")
    super.mimaPreviousVersions()
      .filter(v => Version(v) > cutOff)
  }
}

trait Echo extends Cross.Module[String] with AlmondModule {
  def crossScalaVersion = crossValue
  def moduleDeps = Seq(
    shared.kernel()
  )
  def mvnDeps = Seq(
    Deps.caseApp
  )
  def propertyFilePath = "almond/echo.properties"
  object test extends CrossSbtModuleTests with AlmondTestModule {
    def moduleDeps = super.moduleDeps ++ Seq(
      shared.test()
    )
    // Getting transient errors upon incremental compilation without this
    def scalacOptions = super.scalacOptions
  }
}

trait ToreeHooks extends Cross.Module[String] with AlmondModule {
  def crossScalaVersion = crossValue
  def compileModuleDeps = super.compileModuleDeps ++ Seq(
    scala.`scala-kernel-api`(ScalaVersions.binary(crossScalaVersion))
  )
}

object shared extends Module {
  object `logger-scala2-macros` extends Cross[LoggerScala2Macros](ScalaVersions.scala2Binaries)
  object logger                 extends Cross[Logger](ScalaVersions.binaries)
  object channels               extends Cross[Channels](ScalaVersions.binaries)
  object protocol               extends Cross[Protocol](ScalaVersions.binaries)
  object `interpreter-api`      extends Cross[InterpreterApi](ScalaVersions.binaries)
  object interpreter            extends Cross[Interpreter](ScalaVersions.binaries)
  object kernel                 extends Cross[Kernel](ScalaVersions.binaries)
  object test                   extends Cross[Test](ScalaVersions.binaries)
  object `test-kit`             extends Cross[TestKit](ScalaVersions.all)
}

object scala extends Module {
  object `jupyter-api`       extends Cross[JupyterApi](ScalaVersions.binaries)
  object `scala-kernel-api`  extends Cross[ScalaKernelApi](ScalaVersions.all)
  object `scala-interpreter` extends Cross[ScalaInterpreter](ScalaVersions.all)
  object `scala-kernel`      extends Cross[ScalaKernel](ScalaVersions.all)
  object `coursier-logger`   extends Cross[CoursierLogger](ScalaVersions.binaries)
  object `shared-directives` extends Cross[SharedDirectives](ScalaVersions.binaries)
  object launcher            extends Launcher
  object `almond-scalapy`    extends Cross[AlmondScalaPy](ScalaVersions.binaries)
  object `almond-rx` extends Cross[AlmondRx](Seq(ScalaVersions.scala212, ScalaVersions.scala213))
  object `json-api-jackson` extends Cross[JsonApiJackson](ScalaVersions.binaries)

  object `toree-hooks` extends Cross[ToreeHooks](ScalaVersions.binaries)

  object `test-definitions` extends Cross[TestDefinitions](ScalaVersions.all)
  object integration        extends Integration

  object examples extends Examples
}

object `local-repo` extends Module {
  def allModules: Seq[PublishModule] = {
    val binaryModules = ScalaVersions.binaries.flatMap { sv =>
      Seq(
        scala.`almond-scalapy`(sv),
        shared.kernel(sv),
        shared.interpreter(sv),
        shared.`interpreter-api`(sv),
        shared.protocol(sv),
        shared.channels(sv),
        shared.logger(sv),
        scala.`jupyter-api`(sv),
        scala.`toree-hooks`(sv),
        scala.`json-api-jackson`(sv),
        scala.`coursier-logger`(sv),
        scala.`shared-directives`(sv)
      )
    }
    val binary2Modules = ScalaVersions.scala2Binaries.flatMap { sv =>
      Seq(
        shared.`logger-scala2-macros`(sv)
      )
    }
    val allVersionsModules = (ScalaVersions.scala2Binaries :+ ScalaVersions.scala3Latest).flatMap {
      sv =>
        Seq(
          scala.`scala-kernel`(sv),
          scala.`scala-kernel-api`(sv),
          scala.`scala-interpreter`(sv)
        )
    }
    val simpleModules = Seq(
      scala.launcher
    )

    binaryModules ++ binary2Modules ++ allVersionsModules ++ simpleModules
  }
  def localRepo: T[PathRef] = {
    val allRepos = Task.sequence(allModules.map(_.publishLocalTestRepo))

    Task {
      val allRepos0 = allRepos()
      for (repo <- allRepos0; elem <- os.list(repo.path))
        os.copy.into(elem, Task.dest, mergeFolders = true)
      PathRef(Task.dest)
    }
  }
}

trait Examples extends SbtModule {
  private def examplesScalaVersion = "2.12.20"
  def scalaVersion                 = ScalaVersions.scala3Latest
  def examplesDir                  = Task.Source(BuildCtx.workspaceRoot / "examples")
  object test extends SbtTests {
    def testFramework = "munit.Framework"
    def mvnDeps = Task {
      super.mvnDeps() ++ Seq(
        Deps.expecty,
        Deps.munit,
        Deps.osLib,
        Deps.pprint,
        Deps.upickle
      )
    }
    def forkArgs = Task {
      super.forkArgs() ++ Seq(
        s"-Dalmond.examples.dir=${examplesDir().path}",
        s"-Dalmond.examples.output-dir=${Task.dest / "output"}",
        s"-Dalmond.examples.jupyter-path=${Task.dest / "jupyter"}",
        s"-Dalmond.examples.launcher=${scala.`scala-kernel`(examplesScalaVersion).launcher().path}",
        s"-Dalmond.examples.repo-root=${`local-repo`.localRepo().path}"
      )
    }
  }
}

trait TestKit extends Cross.Module[String] with AlmondCrossSbtModule {
  def crossScalaVersion = crossValue
  def moduleDeps = Seq(
    shared.interpreter()
  )
  def mvnDeps = super.mvnDeps() ++ Seq(
    Deps.expecty,
    Deps.osLib,
    Deps.pprint,
    Deps.testUtil
  )
}

trait TestDefinitions extends Cross.Module[String] with AlmondUnpublishedModule {
  def crossScalaVersion = crossValue

  def moduleDeps = super.moduleDeps ++ Seq(
    shared.`test-kit`()
  )
  def mvnDeps = Task {
    Seq(
      Deps.coursierApi,
      Deps.coursierVersions.withDottyCompat(crossScalaVersion),
      Deps.upickle
    )
  }
}

trait Integration extends SbtModule {
  private def scalaVersion0 = ScalaVersions.scala213
  def scalaVersion          = scalaVersion0

  def moduleDeps = super.moduleDeps ++ Seq(
    shared.`test-kit`(scalaVersion0),
    scala.`test-definitions`(scalaVersion0)
  )
  def mvnDeps = super.mvnDeps() ++ Seq(
    Deps.munit,
    Deps.osLib,
    Deps.pprint,
    Deps.testUtil
  )

  object test extends SbtTests {
    object helper extends ScalaModule {
      def scalaVersion = ScalaVersions.scala3Latest
      def libraryPropertiesScalaVersion = Task {
        if (Version(scalaVersion()) >= Version("3.8.0"))
          scalaVersion()
        else
          runClasspath()
            .map(_.path)
            .map(_.last)
            .filter(_.startsWith("scala-library-2.13."))
            .map(_.stripPrefix("scala-library-"))
            .filter(_.endsWith(".jar"))
            .map(_.stripSuffix(".jar"))
            .filter(!_.contains("-"))
            .headOption
            .getOrElse {
              sys.error(s"Cannot get Scala 2.13 version pulled by Scala ${scalaVersion()}")
            }
      }
    }
    def shapelessVersion = Task {
      scala.`scala-kernel`(ScalaVersions.scala213)
        .compileClasspath()
        .map(_.path)
        .map(_.last)
        .filter(_.startsWith("shapeless_2.13-"))
        .map(_.stripPrefix("shapeless_2.13-"))
        .filter(_.endsWith(".jar"))
        .map(_.stripSuffix(".jar"))
        .headOption
        .getOrElse {
          sys.error("Cannot get shapeless version pulled by scala-kernel")
        }
    }
    def testFramework = "munit.Framework"
    def forkArgs = Task {
      val version = scala.`scala-kernel`(ScalaVersions.scala3Latest).publishVersion()
      super.forkArgs() ++ Seq(
        "-Xmx768m", // let's not use too much memory here, Windows CI sometimes runs short on it
        s"-Dalmond.test.local-repo=${`local-repo`.localRepo().path}",
        s"-Dalmond.test.version=$version",
        s"-Dalmond.test.cs-launcher=${GetCs.cs(Deps.coursier.dep.versionConstraint.asString, "2.1.2")}",
        s"-Dalmond.test.scala-version=${ScalaVersions.scala3Latest}",
        s"-Dalmond.test.scala212-version=${ScalaVersions.scala212}",
        s"-Dalmond.test.scala213-version=${ScalaVersions.scala213}",
        s"-Dalmond.test.library-properties-scala-version=${helper.libraryPropertiesScalaVersion()}",
        s"-Dalmond.test.shapeless-version-pulled-by-kernel=${shapelessVersion()}"
      )
    }
    def tmpDirBase = Task(persistent = true) {
      PathRef(Task.dest / "working-dir")
    }
    def forkEnv = super.forkEnv() ++ Seq(
      "ALMOND_INTEGRATION_TMP" -> tmpDirBase().path.toString
    )
  }
}

object echo extends Cross[Echo](ScalaVersions.binaries)

object docs extends ScalaModule with AlmondRepositories {
  private def scalaVersion0 = ScalaVersions.scala213
  def scalaVersion          = scalaVersion0
  def moduleDeps = Seq(
    scala.`scala-kernel-api`(scalaVersion0)
  )
  def mvnDeps = Seq(
    Deps.mdoc
  )
  def mainClass = Some("mdoc.Main")
  def generate(args: String*) = Task.Command {

    def processArgs(
      npmInstall: Boolean,
      yarnRunBuild: Boolean,
      watch: Boolean,
      relativize: Boolean,
      args: List[String]
    ): (Boolean, Boolean, Boolean, Boolean, List[String]) =
      args match {
        case "--npm-install" :: rem    => processArgs(true, yarnRunBuild, watch, relativize, rem)
        case "--yarn-run-build" :: rem => processArgs(npmInstall, true, watch, relativize, rem)
        case "--watch" :: rem      => processArgs(npmInstall, yarnRunBuild, true, relativize, rem)
        case "--relativize" :: rem => processArgs(npmInstall, yarnRunBuild, watch, true, rem)
        case _                     => (npmInstall, yarnRunBuild, watch, relativize, args)
      }
    val (npmInstall, yarnRunBuild, watch, relativize, args0) =
      processArgs(false, false, false, false, args.toList)

    val ver           = scala.`scala-kernel-api`(scalaVersion0).publishVersion()
    val latestRelease = AlmondPublishModule.latestTaggedVersion()
    val ammVer        = Deps.ammoniteReplApi.dep.versionConstraint.asString
    val scalaVer      = scalaVersion0

    val isSnapshot = ver.endsWith("SNAPSHOT")
    val extraSbt =
      if (isSnapshot) """resolvers += Resolver.sonatypeRepo("snapshots")""" + "\n"
      else ""
    val extraCoursierArgs =
      if (isSnapshot) "-r sonatype:snapshots "
      else ""

    val outputDir = "docs/processed-pages"

    val allArgs = Seq(
      "--in",
      "docs/pages",
      "--out",
      outputDir,
      "--site.VERSION",
      ver,
      "--site.LATEST_RELEASE",
      latestRelease,
      "--site.EXTRA_SBT",
      extraSbt,
      "--site.AMMONITE_VERSION",
      ammVer,
      "--site.SCALA_VERSION",
      scalaVer,
      "--site.SCALA212_VERSION",
      ScalaVersions.scala212,
      "--site.SCALA213_VERSION",
      ScalaVersions.scala213,
      "--site.EXTRA_COURSIER_ARGS",
      extraCoursierArgs
    ) ++ (if (watch) Seq("--watch") else Nil) ++ args0

    // TODO Run yarn run thing right after, add --watch mode

    val websiteDir = BuildCtx.workspaceRoot / "docs" / "website"

    if (npmInstall)
      Util.run(Seq("npm", "install"), dir = websiteDir.toIO)

    def runMdoc(): Unit =
      // adapted from https://github.com/com-lihaoyi/mill/blob/c500ca986ab79af3ce59ba65a093146672092307/scalalib/src/JavaModule.scala#L488-L494
      mill.util.Jvm.callProcess(
        mainClass = finalMainClass(),
        classPath = runClasspath().map(_.path),
        env = forkEnv(),
        mainArgs = allArgs,
        cwd = forkWorkingDir()
      )

    if (watch)
      if (yarnRunBuild)
        Util.withBgProcess(
          Seq("yarn", "run", "start"),
          dir = websiteDir.toIO,
          waitFor =
            () => Util.waitForDir((BuildCtx.workspaceRoot / outputDir.split('/').toSeq).toIO)
        ) {
          runMdoc()
        }
      else
        runMdoc()
    else {
      runMdoc()
      if (yarnRunBuild)
        Util.run(Seq("yarn", "run", "build"), dir = websiteDir.toIO)
      if (relativize)
        Relativize.relativize((websiteDir / "build").toNIO)
    }
  }
}

object dev extends Module {

  def jupyter0(args: Seq[String], fast: Boolean, console: Boolean = false) = {
    val (sv, args0) = args match {
      case Seq(sv, rem @ _*) if sv.startsWith("2.") || sv.startsWith("3.") =>
        (sv, rem)
      case _ => (ScalaVersions.scala213, args)
    }
    val launcher =
      if (fast) scala.`scala-kernel`(sv).fastLauncher
      else scala.`scala-kernel`(sv).launcher
    val specialLauncher =
      if (fast) scala.launcher.fastLauncher
      else scala.launcher.launcher
    Task.Command {
      val jupyterDir       = Task.dest / "jupyter"
      val launcher0        = launcher().path.toNIO
      val specialLauncher0 = specialLauncher().path.toNIO
      val version          = scala.`scala-kernel`(sv).publishVersion()
      val localRepoRoot    = `local-repo`.localRepo().path
      if (console)
        JupyterServer.jupyterConsole(
          launcher0,
          specialLauncher0,
          jupyterDir.toNIO,
          args0,
          BuildCtx.workspaceRoot,
          version,
          localRepoRoot
        )
      else
        JupyterServer.jupyterServer(
          launcher0,
          specialLauncher0,
          jupyterDir.toNIO,
          args0,
          BuildCtx.workspaceRoot,
          version,
          localRepoRoot
        )
    }
  }

  def jupyter(args: String*) =
    jupyter0(args, fast = false)

  def jupyterFast(args: String*) =
    jupyter0(args, fast = true)

  def jupyterConsole(args: String*) =
    jupyter0(args, fast = false, console = true)

  def jupyterConsoleFast(args: String*) =
    jupyter0(args, fast = true, console = true)

  def scala212() = Task.Command {
    println(ScalaVersions.scala212)
  }
  def scala213() = Task.Command {
    println(ScalaVersions.scala213)
  }
  def scala3() = Task.Command {
    println(ScalaVersions.scala3Latest)
  }
  def scalaVersions() = Task.Command {
    for (sv <- ScalaVersions.all)
      mill.api.SystemStreams.original.out.println(sv)
  }

  def launcher(scalaVersion: String = ScalaVersions.scala213) = Task.Command {
    val launcher = scala.`scala-kernel`(scalaVersion).launcher().path.toNIO
    println(launcher)
  }

  def specialLauncher(scalaVersion: String = ScalaVersions.scala213) = Task.Command {
    val launcher = scala.launcher.launcher().path.toNIO
    println(launcher)
  }

  def launcherFast(scalaVersion: String = ScalaVersions.scala213) = Task.Command {
    val launcher = scala.`scala-kernel`(scalaVersion).fastLauncher().path.toNIO
    println(launcher)
  }

  def specialLauncherFast(scalaVersion: String = ScalaVersions.scala213) = Task.Command {
    val launcher = scala.launcher.fastLauncher().path.toNIO
    println(launcher)
  }
}

def ghOrg  = "almond-sh"
def ghName = "almond"
object ci extends Module {
  def uploadLaunchers(almondVersion: String = AlmondPublishModule.computeBuildVersion()) =
    Task.Command {
      def ghToken() = Option(System.getenv("UPLOAD_GH_TOKEN")).getOrElse {
        sys.error("UPLOAD_GH_TOKEN not set")
      }
      val scalaVersions = Seq(
        ScalaVersions.scala212,
        ScalaVersions.scala213,
        ScalaVersions.scala3Latest
      )
      val launchers = scalaVersions.map { sv =>
        val sbv    = sv.split('.').take(2).mkString(".")
        val output = Task.dest / s"launcher-$sv"
        os.proc(
          "cs",
          "bootstrap",
          "--no-default",
          "-r",
          "central",
          "-r",
          "jitpack",
          s"sh.almond:scala-kernel_$sv:$almondVersion",
          "--shared",
          s"sh.almond:scala-kernel-api_$sv",
          "-o",
          output
        ).call(stdin = os.Inherit, stdout = os.Inherit)

        (output, s"almond-scala-$sbv")
      }
      val (tag, overwriteAssets) =
        if (almondVersion.endsWith("-SNAPSHOT")) ("nightly", true)
        else ("v" + almondVersion, false)
      Upload.upload(ghOrg, ghName, ghToken(), tag, dryRun = false, overwrite = overwriteAssets)(
        launchers*
      )
    }
}

object dummy extends Module {
  // dummy module to get Scala Steward updates for ammonite-spark
  object `amm-spark` extends ScalaModule {
    def scalaVersion = ScalaVersions.scala212
    def mvnDeps = super.mvnDeps() ++ Seq(
      Deps.ammoniteSpark
    )
  }
}

object CrossSources {
  def extraSourcesDirs(sv: String): Seq[os.SubPath] = {
    val (maj, min) = sv.split('.') match {
      case Array(maj0, min0, _*) if min0.nonEmpty && min0.forall(_.isDigit) =>
        (maj0, min0.toInt)
      case _ =>
        sys.error(s"Malformed Scala version: $sv")
    }
    val baseDir = os.sub / "src" / "main"
    (0 to min).map(min0 => baseDir / s"scala-$maj.$min0+")
  }
}
